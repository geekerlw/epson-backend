#  init-functions -- -*- sh -*- fall back functions for LSB counterparts
#  Copyright (C) 2007  EPSON AVASYS Corporation
#
#  Permission is hereby granted, free of charge, to any person
#  obtaining a copy of this software and associated documentation files
#  (the "Software"), to deal in the Software without restriction,
#  including without limitation the rights to use, copy, modify, merge,
#  publish, distribute, sublicense, and/or sell copies of the Software,
#  and to permit persons to whom the Software is furnished to do so,
#  subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
#  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
#  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.


#  	implementations aiming for LSB 3.1
#  Please refer to the LSB documents for specifications.

log_success_msg () {
    echo "$@"
}


log_failure_msg () {
    echo "$@"
}


log_warning_msg () {
    echo "$@"
}


pidofproc () {

    local pid_file pathname active pid

    pid_file=
    pathname=
    active=

    OPTIND=1			# pass over the command
    while getopts fn:p: opt; do
	case "$opt" in
	    p)	pid_file="$OPTARG";;
	esac
    done
    shift $(($OPTIND - 1))	# pass over all options

    test $# -ge 1 || return 1

    pathname=$1
    shift

    if test x = x$pid_file; then
	pid_file="/var/run/`basename $pathname`.pid"
    fi

    if test ! -f $pid_file; then
	return 3		# LSB == program not running
    fi

    read line < $pid_file
    for pid in $line; do
	test x = x$pid && continue
	num=`echo $pid | sed 's,^\([0-9]*\).*,\1,'`
	test x$pid = x$num || continue
	# Yes 'ps h' is normally trouble, but we are only listing info
	# for a _single_ process.
	if test x$pid = x`ps h $pid | awk '{print $1}' 2>/dev/null`; then
	    active="$active $pid"
	fi
    done

    if test -z "$active"; then
	return 1		# LSB == program dead, pidfile exists
    fi

    echo $active
    return 0
}


start_daemon () {

    local force nice_lvl pid_file
    local pathname pid

    force=
    nice_lvl=0
    pid_file=
    pathname=

    OPTIND=1			# pass over the command
    while getopts fn:p: opt; do
	case "$opt" in
	    f)	force=true;;
	    n)	nice_lvl="$OPTARG";;
	    p)	pid_file="$OPTARG";;
	esac
    done
    shift $(($OPTIND - 1))	# pass over all options

    test $# -ge 1 || return 1

    pathname=$1
    shift

    if test x = x$pid_file; then
	pid_file="/var/run/`basename $pathname`.pid"
    fi

    if test x != x$force; then
	log_warning_msg "can not run multiple instances"
	return 1
    fi

    for pid in `pidofproc -p $pid_file $pathname`; do
	kill -0 $pid && return 0
    done

    nice -$nice_lvl $pathname -p $pid_file "$@" &

    # FIXME: how to determine whether this daemon process started
    #    successfully?  Can we rely on the daemon to maintain the
    #    pid_file?
}


killproc () {

    local pid_file pathname is_running

    pid_file=
    pathname=
    is_running=

    OPTIND=1			# pass over the command
    while getopts fn:p: opt; do
	case "$opt" in
	    p)	pid_file="$OPTARG";;
	esac
    done
    shift $(($OPTIND - 1))	# pass over all options

    test $# -ge 1 || return 1

    pathname=$1
    shift

    if test x = x$pid_file; then
	pid_file="/var/run/`basename $pathname`.pid"
    fi

    for pid in `pidofproc -p $pid_file $pathname`; do
	is_running=true
	if test $# -ne 0; then
	    kill "$@" $pid >/dev/null 2>&1
	else
	    (kill -TERM $pid; \
	     sleep 5; \
	     kill -KILL $pid) >/dev/null 2>&1 &
	fi
    done

    if test x != x$is_running; then
	rm -f $pid_file || true
    fi

    if test $# -ne 0 && test x != x$is_running; then
	return 0
    fi

    # FIXME: how to determine our return value?
}
